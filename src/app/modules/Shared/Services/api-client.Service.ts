//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { AppConfig } from '../../../app.config';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class service {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : AppConfig.settings.NswagAPIUrl;
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewArea(body: AreaDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Area/AddNewArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewArea(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getAreas(): Observable<GetAreaDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Area/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAreaDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAreaDTOListElBaytResponse>;
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<GetAreaDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAreaDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAreaDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getArea(id: number | undefined): Observable<AreaDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Area/GetArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaDTOElBaytResponse>;
        }));
    }

    protected processGetArea(response: HttpResponseBase): Observable<AreaDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AreaDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AreaDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteArea(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Area/DeleteArea?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteArea(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateArea(body: AreaDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Area/UpdateArea";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateArea(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateArea(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewCity(body: CityDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/City/AddNewCity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewCity(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getCities(): Observable<GetCityDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/City/GetCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCityDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCityDTOListElBaytResponse>;
        }));
    }

    protected processGetCities(response: HttpResponseBase): Observable<GetCityDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetCityDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCityDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCity(id: number | undefined): Observable<CityDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/City/GetCity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTOElBaytResponse>;
        }));
    }

    protected processGetCity(response: HttpResponseBase): Observable<CityDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCity(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/City/DeleteCity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteCity(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCity(body: CityDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/City/UpdateCity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateCity(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param clothBrand_Name (optional) 
     * @param clothBrand_BrandPic (optional) 
     * @param clothBrand_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    addNewClothBrand(clothBrand_Name: string | undefined, clothBrand_BrandPic: string | undefined, clothBrand_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/AddNewClothBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothBrand_Name === null || clothBrand_Name === undefined)
            throw new Error("The parameter 'clothBrand_Name' cannot be null.");
        else
            content_.append("ClothBrand.Name", clothBrand_Name.toString());
        if (clothBrand_BrandPic === null || clothBrand_BrandPic === undefined)
            throw new Error("The parameter 'clothBrand_BrandPic' cannot be null.");
        else
            content_.append("ClothBrand.BrandPic", clothBrand_BrandPic.toString());
        if (clothBrand_Id === null || clothBrand_Id === undefined)
            throw new Error("The parameter 'clothBrand_Id' cannot be null.");
        else
            content_.append("ClothBrand.Id", clothBrand_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewClothBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewClothBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewClothBrand(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothBrands(): Observable<GetClothBrandDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/GetClothBrands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothBrandDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothBrandDTOListElBaytResponse>;
        }));
    }

    protected processGetClothBrands(response: HttpResponseBase): Observable<GetClothBrandDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothBrandDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothBrandDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClothBrand(id: number | undefined): Observable<ClothBrandDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/GetClothBrand?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothBrandDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothBrandDTOElBaytResponse>;
        }));
    }

    protected processGetClothBrand(response: HttpResponseBase): Observable<ClothBrandDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothBrandDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothBrandDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothBrand(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/DeleteClothBrand?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothBrand(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothBrand_Name (optional) 
     * @param clothBrand_BrandPic (optional) 
     * @param clothBrand_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    updateClothBrand(clothBrand_Name: string | undefined, clothBrand_BrandPic: string | undefined, clothBrand_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/UpdateClothBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothBrand_Name === null || clothBrand_Name === undefined)
            throw new Error("The parameter 'clothBrand_Name' cannot be null.");
        else
            content_.append("ClothBrand.Name", clothBrand_Name.toString());
        if (clothBrand_BrandPic === null || clothBrand_BrandPic === undefined)
            throw new Error("The parameter 'clothBrand_BrandPic' cannot be null.");
        else
            content_.append("ClothBrand.BrandPic", clothBrand_BrandPic.toString());
        if (clothBrand_Id === null || clothBrand_Id === undefined)
            throw new Error("The parameter 'clothBrand_Id' cannot be null.");
        else
            content_.append("ClothBrand.Id", clothBrand_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClothBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClothBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateClothBrand(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return Success
     */
    getClothCategoryBrands(categoryId: number | undefined): Observable<DDLInfoDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothBrands/GetClothCategoryBrands?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothCategoryBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothCategoryBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DDLInfoDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DDLInfoDTOListElBaytResponse>;
        }));
    }

    protected processGetClothCategoryBrands(response: HttpResponseBase): Observable<DDLInfoDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DDLInfoDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DDLInfoDTOListElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewClothCategory(body: ClothCategoryDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/AddNewClothCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewClothCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewClothCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewClothCategory(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothCategories(): Observable<GetClothCategoryDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/GetClothCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothCategoryDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothCategoryDTOListElBaytResponse>;
        }));
    }

    protected processGetClothCategories(response: HttpResponseBase): Observable<GetClothCategoryDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothCategoryDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothCategoryDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClothCategory(id: number | undefined): Observable<ClothCategoryDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/GetClothCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothCategoryDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothCategoryDTOElBaytResponse>;
        }));
    }

    protected processGetClothCategory(response: HttpResponseBase): Observable<ClothCategoryDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothCategoryDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothCategoryDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothCategory(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/DeleteClothCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothCategory(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClothCategory(body: ClothCategoryDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/UpdateClothCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClothCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClothCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateClothCategory(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClothCategoryBrands(body: SelectedCategoryBrandsDTO | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/AddClothCategoryBrands";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClothCategoryBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClothCategoryBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processAddClothCategoryBrands(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothcategoryId (optional) 
     * @return Success
     */
    getSelectedClothCategoryBrands(clothcategoryId: number | undefined): Observable<ClothCategoryBrandsDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/GetSelectedClothCategoryBrands?";
        if (clothcategoryId === null)
            throw new Error("The parameter 'clothcategoryId' cannot be null.");
        else if (clothcategoryId !== undefined)
            url_ += "clothcategoryId=" + encodeURIComponent("" + clothcategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedClothCategoryBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedClothCategoryBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothCategoryBrandsDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothCategoryBrandsDTOListElBaytResponse>;
        }));
    }

    protected processGetSelectedClothCategoryBrands(response: HttpResponseBase): Observable<ClothCategoryBrandsDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothCategoryBrandsDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothCategoryBrandsDTOListElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClothCategorySizes(body: SelectedCategorySizesDTO | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/AddClothCategorySizes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClothCategorySizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClothCategorySizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processAddClothCategorySizes(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothcategoryId (optional) 
     * @return Success
     */
    getSelectedClothCategorySizes(clothcategoryId: number | undefined): Observable<ClothCategorySizesDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothCategories/GetSelectedClothCategorySizes?";
        if (clothcategoryId === null)
            throw new Error("The parameter 'clothcategoryId' cannot be null.");
        else if (clothcategoryId !== undefined)
            url_ += "clothcategoryId=" + encodeURIComponent("" + clothcategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedClothCategorySizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedClothCategorySizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothCategorySizesDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothCategorySizesDTOListElBaytResponse>;
        }));
    }

    protected processGetSelectedClothCategorySizes(response: HttpResponseBase): Observable<ClothCategorySizesDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothCategorySizesDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothCategorySizesDTOListElBaytResponse>(null as any);
    }

    /**
     * @param clothDepartment_Name (optional) 
     * @param clothDepartment_DepartmentPic (optional) 
     * @param clothDepartment_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    addNewClothDepartment(clothDepartment_Name: string | undefined, clothDepartment_DepartmentPic: string | undefined, clothDepartment_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothDepartments/AddNewClothDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothDepartment_Name === null || clothDepartment_Name === undefined)
            throw new Error("The parameter 'clothDepartment_Name' cannot be null.");
        else
            content_.append("ClothDepartment.Name", clothDepartment_Name.toString());
        if (clothDepartment_DepartmentPic === null || clothDepartment_DepartmentPic === undefined)
            throw new Error("The parameter 'clothDepartment_DepartmentPic' cannot be null.");
        else
            content_.append("ClothDepartment.DepartmentPic", clothDepartment_DepartmentPic.toString());
        if (clothDepartment_Id === null || clothDepartment_Id === undefined)
            throw new Error("The parameter 'clothDepartment_Id' cannot be null.");
        else
            content_.append("ClothDepartment.Id", clothDepartment_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewClothDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewClothDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewClothDepartment(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothDepartments(): Observable<GetClothDepartmentDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothDepartments/GetClothDepartments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothDepartments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothDepartments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothDepartmentDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothDepartmentDTOListElBaytResponse>;
        }));
    }

    protected processGetClothDepartments(response: HttpResponseBase): Observable<GetClothDepartmentDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothDepartmentDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothDepartmentDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClothDepartment(id: number | undefined): Observable<ClothDepartmentDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothDepartments/GetClothDepartment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothDepartmentDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothDepartmentDTOElBaytResponse>;
        }));
    }

    protected processGetClothDepartment(response: HttpResponseBase): Observable<ClothDepartmentDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothDepartmentDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothDepartmentDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothDepartment(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothDepartments/DeleteClothDepartment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothDepartment(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothDepartment_Name (optional) 
     * @param clothDepartment_DepartmentPic (optional) 
     * @param clothDepartment_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    updateClothDepartment(clothDepartment_Name: string | undefined, clothDepartment_DepartmentPic: string | undefined, clothDepartment_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothDepartments/UpdateClothDepartment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothDepartment_Name === null || clothDepartment_Name === undefined)
            throw new Error("The parameter 'clothDepartment_Name' cannot be null.");
        else
            content_.append("ClothDepartment.Name", clothDepartment_Name.toString());
        if (clothDepartment_DepartmentPic === null || clothDepartment_DepartmentPic === undefined)
            throw new Error("The parameter 'clothDepartment_DepartmentPic' cannot be null.");
        else
            content_.append("ClothDepartment.DepartmentPic", clothDepartment_DepartmentPic.toString());
        if (clothDepartment_Id === null || clothDepartment_Id === undefined)
            throw new Error("The parameter 'clothDepartment_Id' cannot be null.");
        else
            content_.append("ClothDepartment.Id", clothDepartment_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClothDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClothDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateClothDepartment(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param cloth_Name (optional) 
     * @param cloth_Description (optional) 
     * @param cloth_ProductImageURL1 (optional) 
     * @param cloth_ProductImageURL2 (optional) 
     * @param cloth_Category (optional) 
     * @param cloth_ClothCategoryId (optional) 
     * @param cloth_BrandId (optional) 
     * @param cloth_short_desc (optional) 
     * @param files (optional) 
     * @return Success
     */
    addNewCloth(cloth_Name: string | undefined, cloth_Description: string | undefined, cloth_ProductImageURL1: string | undefined, cloth_ProductImageURL2: string | undefined, cloth_Category: EnumProductCategory | undefined, cloth_ClothCategoryId: number | undefined, cloth_BrandId: number | undefined, cloth_short_desc: string | undefined, files: FileParameter[] | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/AddNewCloth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (cloth_Name === null || cloth_Name === undefined)
            throw new Error("The parameter 'cloth_Name' cannot be null.");
        else
            content_.append("Cloth.Name", cloth_Name.toString());
        if (cloth_Description === null || cloth_Description === undefined)
            throw new Error("The parameter 'cloth_Description' cannot be null.");
        else
            content_.append("Cloth.Description", cloth_Description.toString());
        if (cloth_ProductImageURL1 === null || cloth_ProductImageURL1 === undefined)
            throw new Error("The parameter 'cloth_ProductImageURL1' cannot be null.");
        else
            content_.append("Cloth.ProductImageURL1", cloth_ProductImageURL1.toString());
        if (cloth_ProductImageURL2 === null || cloth_ProductImageURL2 === undefined)
            throw new Error("The parameter 'cloth_ProductImageURL2' cannot be null.");
        else
            content_.append("Cloth.ProductImageURL2", cloth_ProductImageURL2.toString());
        if (cloth_Category === null || cloth_Category === undefined)
            throw new Error("The parameter 'cloth_Category' cannot be null.");
        else
            content_.append("Cloth.Category", cloth_Category.toString());
        if (cloth_ClothCategoryId === null || cloth_ClothCategoryId === undefined)
            throw new Error("The parameter 'cloth_ClothCategoryId' cannot be null.");
        else
            content_.append("Cloth.ClothCategoryId", cloth_ClothCategoryId.toString());
        if (cloth_BrandId === null || cloth_BrandId === undefined)
            throw new Error("The parameter 'cloth_BrandId' cannot be null.");
        else
            content_.append("Cloth.BrandId", cloth_BrandId.toString());
        if (cloth_short_desc === null || cloth_short_desc === undefined)
            throw new Error("The parameter 'cloth_short_desc' cannot be null.");
        else
            content_.append("Cloth.short_desc", cloth_short_desc.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewCloth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewCloth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewCloth(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothes(): Observable<GetClothDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetClothes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothDTOListElBaytResponse>;
        }));
    }

    protected processGetClothes(response: HttpResponseBase): Observable<GetClothDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothDTOListElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothesInfo(): Observable<GetClothInfoDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetClothesInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothesInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothesInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothInfoDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothInfoDTOListElBaytResponse>;
        }));
    }

    protected processGetClothesInfo(response: HttpResponseBase): Observable<GetClothInfoDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothInfoDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothInfoDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCloth(id: number | undefined): Observable<NumberClothDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetCloth?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCloth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCloth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NumberClothDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NumberClothDTOElBaytResponse>;
        }));
    }

    protected processGetCloth(response: HttpResponseBase): Observable<NumberClothDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NumberClothDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NumberClothDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCloth(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/DeleteCloth?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCloth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCloth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteCloth(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param cloth_Id (optional) 
     * @param cloth_Name (optional) 
     * @param cloth_Description (optional) 
     * @param cloth_ProductImageURL1 (optional) 
     * @param cloth_ProductImageURL2 (optional) 
     * @param cloth_Category (optional) 
     * @param cloth_ClothCategoryId (optional) 
     * @param cloth_BrandId (optional) 
     * @param cloth_short_desc (optional) 
     * @param files (optional) 
     * @return Success
     */
    updateCloth(cloth_Id: string | undefined, cloth_Name: string | undefined, cloth_Description: string | undefined, cloth_ProductImageURL1: string | undefined, cloth_ProductImageURL2: string | undefined, cloth_Category: EnumProductCategory | undefined, cloth_ClothCategoryId: number | undefined, cloth_BrandId: number | undefined, cloth_short_desc: string | undefined, files: FileParameter[] | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/UpdateCloth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (cloth_Id === null || cloth_Id === undefined)
            throw new Error("The parameter 'cloth_Id' cannot be null.");
        else
            content_.append("Cloth.Id", cloth_Id.toString());
        if (cloth_Name === null || cloth_Name === undefined)
            throw new Error("The parameter 'cloth_Name' cannot be null.");
        else
            content_.append("Cloth.Name", cloth_Name.toString());
        if (cloth_Description === null || cloth_Description === undefined)
            throw new Error("The parameter 'cloth_Description' cannot be null.");
        else
            content_.append("Cloth.Description", cloth_Description.toString());
        if (cloth_ProductImageURL1 === null || cloth_ProductImageURL1 === undefined)
            throw new Error("The parameter 'cloth_ProductImageURL1' cannot be null.");
        else
            content_.append("Cloth.ProductImageURL1", cloth_ProductImageURL1.toString());
        if (cloth_ProductImageURL2 === null || cloth_ProductImageURL2 === undefined)
            throw new Error("The parameter 'cloth_ProductImageURL2' cannot be null.");
        else
            content_.append("Cloth.ProductImageURL2", cloth_ProductImageURL2.toString());
        if (cloth_Category === null || cloth_Category === undefined)
            throw new Error("The parameter 'cloth_Category' cannot be null.");
        else
            content_.append("Cloth.Category", cloth_Category.toString());
        if (cloth_ClothCategoryId === null || cloth_ClothCategoryId === undefined)
            throw new Error("The parameter 'cloth_ClothCategoryId' cannot be null.");
        else
            content_.append("Cloth.ClothCategoryId", cloth_ClothCategoryId.toString());
        if (cloth_BrandId === null || cloth_BrandId === undefined)
            throw new Error("The parameter 'cloth_BrandId' cannot be null.");
        else
            content_.append("Cloth.BrandId", cloth_BrandId.toString());
        if (cloth_short_desc === null || cloth_short_desc === undefined)
            throw new Error("The parameter 'cloth_short_desc' cannot be null.");
        else
            content_.append("Cloth.short_desc", cloth_short_desc.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCloth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCloth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateCloth(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param file (optional) 
     * @param clothId (optional) 
     * @return Success
     */
    uploadClothImage(file: FileParameter | undefined, clothId: number | undefined): Observable<ClothImageDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/UploadClothImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (clothId === null || clothId === undefined)
            throw new Error("The parameter 'clothId' cannot be null.");
        else
            content_.append("ClothId", clothId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadClothImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadClothImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothImageDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothImageDTOElBaytResponse>;
        }));
    }

    protected processUploadClothImage(response: HttpResponseBase): Observable<ClothImageDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothImageDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothImageDTOElBaytResponse>(null as any);
    }

    /**
     * @param clothId (optional) 
     * @return Success
     */
    getClothImages(clothId: number | undefined): Observable<ClothImageDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetClothImages?";
        if (clothId === null)
            throw new Error("The parameter 'clothId' cannot be null.");
        else if (clothId !== undefined)
            url_ += "clothId=" + encodeURIComponent("" + clothId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothImageDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothImageDTOListElBaytResponse>;
        }));
    }

    protected processGetClothImages(response: HttpResponseBase): Observable<ClothImageDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothImageDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothImageDTOListElBaytResponse>(null as any);
    }

    /**
     * @param imageId (optional) 
     * @return Success
     */
    deleteClothImage(imageId: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/DeleteClothImage?";
        if (imageId === null)
            throw new Error("The parameter 'imageId' cannot be null.");
        else if (imageId !== undefined)
            url_ += "ImageId=" + encodeURIComponent("" + imageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothImage(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param uRL (optional) 
     * @return Success
     */
    deleteClothImageByURL(uRL: string | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/DeleteClothImageByURL?";
        if (uRL === null)
            throw new Error("The parameter 'uRL' cannot be null.");
        else if (uRL !== undefined)
            url_ += "URL=" + encodeURIComponent("" + uRL) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothImageByURL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothImageByURL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothImageByURL(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothId (optional) 
     * @return Success
     */
    getClothDBLInfo(clothId: number | undefined): Observable<ClothDBLDataDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetClothDBLInfo?";
        if (clothId === null)
            throw new Error("The parameter 'clothId' cannot be null.");
        else if (clothId !== undefined)
            url_ += "clothId=" + encodeURIComponent("" + clothId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothDBLInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothDBLInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothDBLDataDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothDBLDataDTOElBaytResponse>;
        }));
    }

    protected processGetClothDBLInfo(response: HttpResponseBase): Observable<ClothDBLDataDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothDBLDataDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothDBLDataDTOElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClothInfo(body: ClothInfoDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/AddClothInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClothInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClothInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddClothInfo(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param clothId (optional) 
     * @return Success
     */
    getClothInfo(clothId: number | undefined): Observable<ClothInfoDataDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetClothInfo?";
        if (clothId === null)
            throw new Error("The parameter 'clothId' cannot be null.");
        else if (clothId !== undefined)
            url_ += "clothId=" + encodeURIComponent("" + clothId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothInfoDataDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothInfoDataDTOListElBaytResponse>;
        }));
    }

    protected processGetClothInfo(response: HttpResponseBase): Observable<ClothInfoDataDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothInfoDataDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothInfoDataDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothInfo(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/DeleteClothInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothInfo(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInfo(id: number | undefined): Observable<ClothInfoDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Clothes/GetInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothInfoDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothInfoDTOElBaytResponse>;
        }));
    }

    protected processGetInfo(response: HttpResponseBase): Observable<ClothInfoDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothInfoDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothInfoDTOElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewClothSize(body: ClothSizeDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/AddNewClothSize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewClothSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewClothSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewClothSize(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getSizes(): Observable<GetClothSizeDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/GetSizes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothSizeDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothSizeDTOListElBaytResponse>;
        }));
    }

    protected processGetSizes(response: HttpResponseBase): Observable<GetClothSizeDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothSizeDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothSizeDTOListElBaytResponse>(null as any);
    }

    /**
     * @param clothId (optional) 
     * @return Success
     */
    getClothSizes(clothId: number | undefined): Observable<GetClothSizeDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/GetClothSizes?";
        if (clothId === null)
            throw new Error("The parameter 'clothId' cannot be null.");
        else if (clothId !== undefined)
            url_ += "ClothId=" + encodeURIComponent("" + clothId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothSizes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothSizes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothSizeDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothSizeDTOListElBaytResponse>;
        }));
    }

    protected processGetClothSizes(response: HttpResponseBase): Observable<GetClothSizeDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothSizeDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothSizeDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClothSize(id: number | undefined): Observable<ClothSizeDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/GetClothSize?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothSizeDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothSizeDTOElBaytResponse>;
        }));
    }

    protected processGetClothSize(response: HttpResponseBase): Observable<ClothSizeDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothSizeDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothSizeDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothSize(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/DeleteClothSize?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothSize(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClothSize(body: ClothSizeDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothSizes/UpdateClothSize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClothSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClothSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateClothSize(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param clothType_ClothDepartmentId (optional) 
     * @param clothType_Name (optional) 
     * @param clothType_TypePic (optional) 
     * @param clothType_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    addNewClothType(clothType_ClothDepartmentId: number | undefined, clothType_Name: string | undefined, clothType_TypePic: string | undefined, clothType_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothTypes/AddNewClothType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothType_ClothDepartmentId === null || clothType_ClothDepartmentId === undefined)
            throw new Error("The parameter 'clothType_ClothDepartmentId' cannot be null.");
        else
            content_.append("ClothType.ClothDepartmentId", clothType_ClothDepartmentId.toString());
        if (clothType_Name === null || clothType_Name === undefined)
            throw new Error("The parameter 'clothType_Name' cannot be null.");
        else
            content_.append("ClothType.Name", clothType_Name.toString());
        if (clothType_TypePic === null || clothType_TypePic === undefined)
            throw new Error("The parameter 'clothType_TypePic' cannot be null.");
        else
            content_.append("ClothType.TypePic", clothType_TypePic.toString());
        if (clothType_Id === null || clothType_Id === undefined)
            throw new Error("The parameter 'clothType_Id' cannot be null.");
        else
            content_.append("ClothType.Id", clothType_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewClothType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewClothType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewClothType(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getClothTypes(): Observable<GetClothTypeDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothTypes/GetClothTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetClothTypeDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetClothTypeDTOListElBaytResponse>;
        }));
    }

    protected processGetClothTypes(response: HttpResponseBase): Observable<GetClothTypeDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetClothTypeDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClothTypeDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getClothType(id: number | undefined): Observable<ClothTypeDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothTypes/GetClothType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClothType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClothType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClothTypeDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClothTypeDTOElBaytResponse>;
        }));
    }

    protected processGetClothType(response: HttpResponseBase): Observable<ClothTypeDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClothTypeDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClothTypeDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteClothType(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothTypes/DeleteClothType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClothType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClothType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteClothType(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param clothType_ClothDepartmentId (optional) 
     * @param clothType_Name (optional) 
     * @param clothType_TypePic (optional) 
     * @param clothType_Id (optional) 
     * @param files (optional) 
     * @return Success
     */
    updateClothType(clothType_ClothDepartmentId: number | undefined, clothType_Name: string | undefined, clothType_TypePic: string | undefined, clothType_Id: number | undefined, files: FileParameter | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/ClothTypes/UpdateClothType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (clothType_ClothDepartmentId === null || clothType_ClothDepartmentId === undefined)
            throw new Error("The parameter 'clothType_ClothDepartmentId' cannot be null.");
        else
            content_.append("ClothType.ClothDepartmentId", clothType_ClothDepartmentId.toString());
        if (clothType_Name === null || clothType_Name === undefined)
            throw new Error("The parameter 'clothType_Name' cannot be null.");
        else
            content_.append("ClothType.Name", clothType_Name.toString());
        if (clothType_TypePic === null || clothType_TypePic === undefined)
            throw new Error("The parameter 'clothType_TypePic' cannot be null.");
        else
            content_.append("ClothType.TypePic", clothType_TypePic.toString());
        if (clothType_Id === null || clothType_Id === undefined)
            throw new Error("The parameter 'clothType_Id' cannot be null.");
        else
            content_.append("ClothType.Id", clothType_Id.toString());
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            content_.append("Files", files.data, files.fileName ? files.fileName : "Files");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClothType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClothType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateClothType(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewColor(body: ColorDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Color/AddNewColor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewColor(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getColors(): Observable<GetColorDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Color/GetColors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColors(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetColorDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetColorDTOListElBaytResponse>;
        }));
    }

    protected processGetColors(response: HttpResponseBase): Observable<GetColorDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetColorDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetColorDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getColor(id: number | undefined): Observable<ColorDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Color/GetColor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ColorDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ColorDTOElBaytResponse>;
        }));
    }

    protected processGetColor(response: HttpResponseBase): Observable<ColorDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ColorDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ColorDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteColor(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Color/DeleteColor?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteColor(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateColor(body: ColorDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Color/UpdateColor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateColor(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewCountry(body: CountryDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Country/AddNewCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewCountry(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<GetCountryDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Country/GetCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCountryDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCountryDTOListElBaytResponse>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<GetCountryDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetCountryDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountryDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCountry(id: number | undefined): Observable<CityDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Country/GetCountry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDTOElBaytResponse>;
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<CityDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CityDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CityDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCountry(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Country/DeleteCountry?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteCountry(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCountry(body: CountryDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Country/UpdateCountry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateCountry(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewGovernorate(body: GovernorateDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Governorate/AddNewGovernorate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processAddNewGovernorate(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getGovernorates(): Observable<GetGovernorateDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Governorate/GetGovernorates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGovernorates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGovernorates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGovernorateDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGovernorateDTOListElBaytResponse>;
        }));
    }

    protected processGetGovernorates(response: HttpResponseBase): Observable<GetGovernorateDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetGovernorateDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGovernorateDTOListElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGovernorate(id: number | undefined): Observable<GovernorateDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Governorate/GetGovernorate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GovernorateDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GovernorateDTOElBaytResponse>;
        }));
    }

    protected processGetGovernorate(response: HttpResponseBase): Observable<GovernorateDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GovernorateDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GovernorateDTOElBaytResponse>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteGovernorate(id: number | undefined): Observable<BooleanElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Governorate/DeleteGovernorate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanElBaytResponse>;
        }));
    }

    protected processDeleteGovernorate(response: HttpResponseBase): Observable<BooleanElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGovernorate(body: GovernorateDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Governorate/UpdateGovernorate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGovernorate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGovernorate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processUpdateGovernorate(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<AppUserDataDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Identity/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppUserDataDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppUserDataDTOElBaytResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AppUserDataDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AppUserDataDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppUserDataDTOElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: AppUserDTO | undefined): Observable<StringElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Identity/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringElBaytResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<StringElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringElBaytResponse>(null as any);
    }

    /**
     * @return Success
     */
    getOrders(): Observable<OrderDTOListElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Orders/GetOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDTOListElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDTOListElBaytResponse>;
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<OrderDTOListElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderDTOListElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderDTOListElBaytResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrderStatus(body: AddOrderStatusDTO | undefined): Observable<OrderStatusDetailDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Orders/UpdateOrderStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrderStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStatusDetailDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStatusDetailDTOElBaytResponse>;
        }));
    }

    protected processUpdateOrderStatus(response: HttpResponseBase): Observable<OrderStatusDetailDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderStatusDetailDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderStatusDetailDTOElBaytResponse>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getOrderStatuses(orderId: number | undefined): Observable<OrderStatusesDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Orders/GetOrderStatuses?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStatuses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStatuses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStatusesDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStatusesDTOElBaytResponse>;
        }));
    }

    protected processGetOrderStatuses(response: HttpResponseBase): Observable<OrderStatusesDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderStatusesDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderStatusesDTOElBaytResponse>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getOrderStatusDetails(orderId: number | undefined): Observable<OrderStatusDetailDTOElBaytResponse> {
        let url_ = this.baseUrl + "/api/v1.0/ElBayt/Orders/GetOrderStatusDetails?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStatusDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStatusDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStatusDetailDTOElBaytResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStatusDetailDTOElBaytResponse>;
        }));
    }

    protected processGetOrderStatusDetails(response: HttpResponseBase): Observable<OrderStatusDetailDTOElBaytResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OrderStatusDetailDTOElBaytResponse;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderStatusDetailDTOElBaytResponse>(null as any);
    }
}

export interface AddOrderStatusDTO {
    OrderId?: number;
    StatusId?: number;
}

export interface AppUserDTO {
    Name?: string | undefined;
    PhoneNumber?: string | undefined;
    PasswordHash?: string | undefined;
    Email?: string | undefined;
    UserName?: string | undefined;
    Id?: string;
    AccessFailedCount?: string | undefined;
}

export interface AppUserDataDTO {
    Name?: string | undefined;
    Email?: string | undefined;
    UserName?: string | undefined;
    token?: string | undefined;
}

export interface AppUserDataDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: AppUserDataDTO;
    Errors?: string[] | undefined;
}

export interface AreaDTO {
    Id?: number;
    CreatedDate?: Date | undefined;
    CreatedBy?: string | undefined;
    ModifiedDate?: Date | undefined;
    ModifiedBy?: string | undefined;
    Name?: string | undefined;
    CityId?: number;
}

export interface AreaDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: AreaDTO;
    Errors?: string[] | undefined;
}

export interface BooleanElBaytResponse {
    Result?: EnumResponseResult;
    Data?: boolean;
    Errors?: string[] | undefined;
}

export interface CityDTO {
    Id?: number;
    CreatedDate?: Date | undefined;
    CreatedBy?: string | undefined;
    ModifiedDate?: Date | undefined;
    ModifiedBy?: string | undefined;
    Name?: string | undefined;
    GovernorateId?: number;
}

export interface CityDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: CityDTO;
    Errors?: string[] | undefined;
}

export interface ClothBrandDTO {
    Id?: number;
    Name?: string | undefined;
    BrandPic?: string | undefined;
}

export interface ClothBrandDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothBrandDTO;
    Errors?: string[] | undefined;
}

export interface ClothCategoryBrandsDTO {
    Id?: number;
    Name?: string | undefined;
    Checked?: boolean;
}

export interface ClothCategoryBrandsDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothCategoryBrandsDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface ClothCategoryDTO {
    Id?: number;
    Name?: string | undefined;
    ClothTypeId?: number;
}

export interface ClothCategoryDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothCategoryDTO;
    Errors?: string[] | undefined;
}

export interface ClothCategorySizesDTO {
    Id?: number;
    Name?: string | undefined;
    Checked?: boolean;
}

export interface ClothCategorySizesDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothCategorySizesDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface ClothDBLDataDTO {
    Colors?: DDLColorInfoDTO[] | undefined;
    Sizes?: DDLInfoDTO[] | undefined;
}

export interface ClothDBLDataDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothDBLDataDTO;
    Errors?: string[] | undefined;
}

export interface ClothDepartmentDTO {
    Id?: number;
    Name?: string | undefined;
    DepartmentPic?: string | undefined;
}

export interface ClothDepartmentDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothDepartmentDTO;
    Errors?: string[] | undefined;
}

export interface ClothImageDTO {
    Id?: number;
    CreatedDate?: Date | undefined;
    CreatedBy?: string | undefined;
    ModifiedDate?: Date | undefined;
    ModifiedBy?: string | undefined;
    URL?: string | undefined;
    ClothId?: number;
}

export interface ClothImageDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothImageDTO;
    Errors?: string[] | undefined;
}

export interface ClothImageDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothImageDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface ClothInfoDTO {
    Id?: number;
    ClothId?: number;
    Price?: number;
    PriceAfterDiscount?: number | undefined;
    SizeId?: number;
    ColorId?: number | undefined;
    Amount?: number;
}

export interface ClothInfoDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothInfoDTO;
    Errors?: string[] | undefined;
}

export interface ClothInfoDataDTO {
    Id?: number;
    Price?: string | undefined;
    PriceAfterDiscount?: string | undefined;
    Size?: string | undefined;
    Color?: string | undefined;
    Amount?: string | undefined;
}

export interface ClothInfoDataDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothInfoDataDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface ClothSizeDTO {
    Id?: number;
    Name?: string | undefined;
    Height?: number | undefined;
    Width?: number | undefined;
    Abbreviation?: string | undefined;
}

export interface ClothSizeDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothSizeDTO;
    Errors?: string[] | undefined;
}

export interface ClothTypeDTO {
    Id?: number;
    Name?: string | undefined;
    TypePic?: string | undefined;
    ClothDepartmentId?: number;
}

export interface ClothTypeDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ClothTypeDTO;
    Errors?: string[] | undefined;
}

export interface ColorDTO {
    Id?: number;
    Name?: string | undefined;
    Color?: string | undefined;
}

export interface ColorDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: ColorDTO;
    Errors?: string[] | undefined;
}

export interface CountryDTO {
    Id?: number;
    CreatedDate?: Date | undefined;
    CreatedBy?: string | undefined;
    ModifiedDate?: Date | undefined;
    ModifiedBy?: string | undefined;
    Name?: string | undefined;
}

export interface DDLColorInfoDTO {
    Id?: number;
    Name?: string | undefined;
    Color?: string | undefined;
}

export interface DDLInfoDTO {
    Id?: number;
    Name?: string | undefined;
}

export interface DDLInfoDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: DDLInfoDTO[] | undefined;
    Errors?: string[] | undefined;
}

export enum EnumProductCategory {
    _0 = 0,
}

export enum EnumResponseResult {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface GetAreaDTO {
    Id?: number;
    Name?: string | undefined;
    CityId?: number;
}

export interface GetAreaDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetAreaDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetCityDTO {
    Id?: number;
    Name?: string | undefined;
    GovernorateId?: number;
}

export interface GetCityDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetCityDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothBrandDTO {
    Id?: number;
    Name?: string | undefined;
    BrandPic?: string | undefined;
}

export interface GetClothBrandDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothBrandDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothCategoryDTO {
    Id?: number;
    Name?: string | undefined;
    ClothTypeId?: number;
}

export interface GetClothCategoryDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothCategoryDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothDTO {
    Id?: number;
    ClothCategoryId?: number;
    Name?: string | undefined;
    Description?: string | undefined;
    ProductImageURL1?: string | undefined;
    ProductImageURL2?: string | undefined;
    Quantity?: number;
    Reviews?: number;
    Ratings?: number;
}

export interface GetClothDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothDepartmentDTO {
    Id?: number;
    Name?: string | undefined;
    DepartmentPic?: string | undefined;
}

export interface GetClothDepartmentDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothDepartmentDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothInfoDTO {
    Id?: number;
    ClothId?: number;
    Price?: number;
    PriceAfterDiscount?: number;
    SizeId?: number;
    ColorId?: string | undefined;
    Amount?: number;
}

export interface GetClothInfoDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothInfoDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothSizeDTO {
    Id?: number;
    Name?: string | undefined;
    Height?: number | undefined;
    Width?: number | undefined;
    Abbreviation?: string | undefined;
}

export interface GetClothSizeDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothSizeDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetClothTypeDTO {
    Id?: number;
    Name?: string | undefined;
}

export interface GetClothTypeDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetClothTypeDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetColorDTO {
    Id?: number;
    Name?: string | undefined;
    Color?: string | undefined;
}

export interface GetColorDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetColorDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetCountryDTO {
    Id?: number;
    Name?: string | undefined;
}

export interface GetCountryDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetCountryDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GetGovernorateDTO {
    Id?: number;
    Name?: string | undefined;
    CountryId?: number;
}

export interface GetGovernorateDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GetGovernorateDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface GovernorateDTO {
    Id?: number;
    CreatedDate?: Date | undefined;
    CreatedBy?: string | undefined;
    ModifiedDate?: Date | undefined;
    ModifiedBy?: string | undefined;
    Name?: string | undefined;
    CountryId?: number;
}

export interface GovernorateDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: GovernorateDTO;
    Errors?: string[] | undefined;
}

export interface LoginModel {
    UserName?: string | undefined;
    Password?: string | undefined;
}

export interface NumberClothDTO {
    RowNum?: number;
    Id?: number;
    Name?: string | undefined;
    Price?: string | undefined;
    PriceAfterDiscount?: string | undefined;
    short_desc?: string | undefined;
    Description?: string | undefined;
    ProductImageURL1?: string | undefined;
    ProductImageURL2?: string | undefined;
    ClothCategoryId?: number;
    ClothCategoryName?: string | undefined;
    BrandId?: number;
}

export interface NumberClothDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: NumberClothDTO;
    Errors?: string[] | undefined;
}

export interface OrderDTO {
    Id?: number;
    ClientName?: string | undefined;
    OrderStatus?: string | undefined;
    OrderTime?: Date;
}

export interface OrderDTOListElBaytResponse {
    Result?: EnumResponseResult;
    Data?: OrderDTO[] | undefined;
    Errors?: string[] | undefined;
}

export interface OrderLookupStatusDTO {
    Id?: number;
    StatusName?: string | undefined;
}

export interface OrderStatusDTO {
    StatusId?: number;
    StatusName?: string | undefined;
    CreatedDate?: Date;
    Id?: number;
}

export interface OrderStatusDetailDTO {
    OrderStatuses?: OrderStatusesDTO;
    CurrentStatusName?: string | undefined;
    CurrentStatusId?: number;
    Statuses?: OrderLookupStatusDTO[] | undefined;
}

export interface OrderStatusDetailDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: OrderStatusDetailDTO;
    Errors?: string[] | undefined;
}

export interface OrderStatusesDTO {
    Statuses?: OrderStatusDTO[] | undefined;
    OrderId?: number;
}

export interface OrderStatusesDTOElBaytResponse {
    Result?: EnumResponseResult;
    Data?: OrderStatusesDTO;
    Errors?: string[] | undefined;
}

export interface SelectedCategoryBrandsDTO {
    Brands?: number[] | undefined;
    ClothCategoryId?: number;
}

export interface SelectedCategorySizesDTO {
    Sizes?: number[] | undefined;
    ClothCategoryId?: number;
}

export interface StringElBaytResponse {
    Result?: EnumResponseResult;
    Data?: string | undefined;
    Errors?: string[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
